=head1 NAME

builtin.imc - builtin and user defined macros

=head2 DESCRIPTION

Copyright:  2004 Bernhard Schmalhofer.  All Rights Reserved.
CVS Info:   $Id$
History:    Ported from GNU m4 1.4
References: http://www.gnu.org/software/m4/m4.html

Code for all builtin macros, initialisation of symbol table, and
expansion of user defined macros.

=cut

# Some named constants
.include '../../runtime/parrot/include/iterator.pasm'

=head1 SUBROUTINES

=head2 void _builtin_tab_init( PerlHash state )

Initialise all builtin and predefined macros.

=cut

.sub _builtin_tab_init 
  .param PerlHash state

  # Generate a table of Sub
  .local pmc builtin_tab
  builtin_tab = state['builtin_tab']

  .local pmc builtin
  .local Sub func

  #   { "__file__",		TRUE,	FALSE,	FALSE,	m4___file__ },
  builtin = new PerlHash
  builtin['name'] = '__file__'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['__file__'] = builtin

  #   { "__line__",		TRUE,	FALSE,	FALSE,	m4___line__ },
  builtin = new PerlHash
  builtin['name'] = '__line__'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['__line__'] = builtin

  #   { "builtin",		TRUE,	FALSE,	TRUE,	m4_builtin },
  builtin = new PerlHash
  builtin['name'] = 'builtin'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['builtin'] = builtin

  #   { "changecom",	FALSE,	FALSE,	FALSE,	m4_changecom },
  builtin = new PerlHash
  builtin['name'] = 'changecom'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['changecom'] = builtin

  #   { "changequote",	FALSE,	FALSE,	FALSE,	m4_changequote },
  builtin = new PerlHash
  builtin['name'] = 'changequote'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['changequote'] = builtin

  #   { "changeword",	TRUE,	FALSE,	FALSE,	m4_changeword },
  builtin = new PerlHash
  builtin['name'] = 'changeword'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['changeword'] = builtin

  #   { "debugmode",	TRUE,	FALSE,	FALSE,	m4_debugmode },
  builtin = new PerlHash
  builtin['name'] = 'debugmode'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['debugmode'] = builtin

  #   { "debugfile",	TRUE,	FALSE,	FALSE,	m4_debugfile },
  builtin = new PerlHash
  builtin['name'] = 'debugfile'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['debugfile'] = builtin

  #   { "decr",		FALSE,	FALSE,	TRUE,	m4_decr },
  builtin = new PerlHash
  builtin['name'] = 'decr'
  func = newsub _m4_decr
  builtin['func'] = func 
  builtin_tab['decr'] = builtin

  #   { "define",		FALSE,	TRUE,	TRUE,	m4_define },
  builtin = new PerlHash
  builtin['name'] = 'define'
  func = newsub _m4_define
  builtin['func'] = func 
  builtin_tab['define'] = builtin

  #   { "defn",		FALSE,	FALSE,	TRUE,	m4_defn },
  builtin = new PerlHash
  builtin['name'] = 'defn'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['defn'] = builtin

  #   { "divert",		FALSE,	FALSE,	FALSE,	m4_divert },
  builtin = new PerlHash
  builtin['name'] = 'divert'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['divert'] = builtin

  #   { "divnum",		FALSE,	FALSE,	FALSE,	m4_divnum },
  builtin = new PerlHash
  builtin['name'] = 'divnum'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['divnum'] = builtin

  #   { "dnl",		FALSE,	FALSE,	FALSE,	m4_dnl },
  builtin = new PerlHash
  builtin['name'] = 'dnl'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['dnl'] = builtin

  #   { "dumpdef",		FALSE,	FALSE,	FALSE,	m4_dumpdef },
  builtin = new PerlHash
  builtin['name'] = 'dumpdef'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['dumpdef'] = builtin

  #   { "errprint",		FALSE,	FALSE,	FALSE,	m4_errprint },
  builtin = new PerlHash
  builtin['name'] = 'errprint'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['errprint'] = builtin

  #   { "esyscmd",		TRUE,	FALSE,	TRUE,	m4_esyscmd },
  builtin = new PerlHash
  builtin['name'] = 'esyscmd'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['esyscmd'] = builtin

  #   { "eval",		FALSE,	FALSE,	TRUE,	m4_eval },
  builtin = new PerlHash
  builtin['name'] = 'eval'
  func = newsub _m4_eval
  builtin['func'] = func 
  builtin_tab['eval'] = builtin

  #   { "format",		TRUE,	FALSE,	FALSE,	m4_format },
  builtin = new PerlHash
  builtin['name'] = 'format'
  func = newsub _m4_format
  builtin['func'] = func 
  builtin_tab['format'] = builtin

  #   { "ifdef",		FALSE,	FALSE,	TRUE,	m4_ifdef },
  builtin = new PerlHash
  builtin['name'] = 'ifdef'
  func = newsub _m4_ifdef
  builtin['func'] = func 
  builtin_tab['ifdef'] = builtin

  #   { "ifelse",		FALSE,	FALSE,	TRUE,	m4_ifelse },
  builtin = new PerlHash
  builtin['name'] = 'ifelse'
  func = newsub _m4_ifelse
  builtin['func'] = func 
  builtin_tab['ifelse'] = builtin

  #   { "include",		FALSE,	FALSE,	TRUE,	m4_include },
  builtin = new PerlHash
  builtin['name'] = 'include'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['include'] = builtin

  #   { "incr",		FALSE,	FALSE,	TRUE,	m4_incr },
  builtin = new PerlHash
  builtin['name'] = 'incr'
  func = newsub _m4_incr
  builtin['func'] = func 
  builtin_tab['incr'] = builtin

  #   { "index",		FALSE,	FALSE,	TRUE,	m4_index },
  builtin = new PerlHash
  builtin['name'] = 'index'
  func = newsub _m4_index
  builtin['func'] = func 
  builtin_tab['index'] = builtin

  #   { "indir",		TRUE,	FALSE,	FALSE,	m4_indir },
  builtin = new PerlHash
  builtin['name'] = 'indir'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['indir'] = builtin

  #   { "len",		FALSE,	FALSE,	TRUE,	m4_len },
  builtin = new PerlHash
  builtin['name'] = 'len'
  func = newsub _m4_len
  builtin['func'] = func 
  builtin_tab['len'] = builtin

  #   { "m4exit",		FALSE,	FALSE,	FALSE,	m4_m4exit },
  builtin = new PerlHash
  builtin['name'] = 'm4exit'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['m4exit'] = builtin

  #   { "m4wrap",		FALSE,	FALSE,	FALSE,	m4_m4wrap },
  builtin = new PerlHash
  builtin['name'] = 'm4wrap'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['m4wrap'] = builtin

  #   { "maketemp",		FALSE,	FALSE,	TRUE,	m4_maketemp },
  builtin = new PerlHash
  builtin['name'] = 'maketemp'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['maketemp'] = builtin

  #   { "patsubst",		TRUE,	FALSE,	TRUE,	m4_patsubst },
  builtin = new PerlHash
  builtin['name'] = 'patsubst'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['patsubst'] = builtin

  #   { "popdef",		FALSE,	FALSE,	TRUE,	m4_popdef },
  builtin = new PerlHash
  builtin['name'] = 'popdef'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['popdef'] = builtin

  #   { "pushdef",		FALSE,	TRUE,	TRUE,	m4_pushdef },
  builtin = new PerlHash
  builtin['name'] = 'pushdef'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['pushdef'] = builtin

  #   { "regexp",		TRUE,	FALSE,	TRUE,	m4_regexp },
  builtin = new PerlHash
  builtin['name'] = 'regexp'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['regexp'] = builtin

  #   { "shift",		FALSE,	FALSE,	FALSE,	m4_shift },
  builtin = new PerlHash
  builtin['name'] = 'shift'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['shift'] = builtin

  #   { "sinclude",		FALSE,	FALSE,	TRUE,	m4_sinclude },
  builtin = new PerlHash
  builtin['name'] = 'sinclude'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['sinclude'] = builtin

  #   { "substr",		FALSE,	FALSE,	TRUE,	m4_substr },
  builtin = new PerlHash
  builtin['name'] = 'substr'
  func = newsub _m4_substr
  builtin['func'] = func 
  builtin_tab['substr'] = builtin

  #   { "syscmd",		FALSE,	FALSE,	TRUE,	m4_syscmd },
  builtin = new PerlHash
  builtin['name'] = 'syscmd'
  func = newsub _m4_syscmd
  builtin['func'] = func 
  builtin_tab['syscmd'] = builtin

  #   { "sysval",		FALSE,	FALSE,	FALSE,	m4_sysval },
  builtin = new PerlHash
  builtin['name'] = 'sysval'
  func = newsub _m4_sysval
  builtin['func'] = func 
  builtin_tab['sysval'] = builtin

  #   { "traceoff",		FALSE,	FALSE,	FALSE,	m4_traceoff },
  builtin = new PerlHash
  builtin['name'] = 'traceoff'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['traceoff'] = builtin

  #   { "traceon",		FALSE,	FALSE,	FALSE,	m4_traceon },
  builtin = new PerlHash
  builtin['name'] = 'traceon'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['traceon'] = builtin

  #   { "translit",		FALSE,	FALSE,	TRUE,	m4_translit },
  builtin = new PerlHash
  builtin['name'] = 'translit'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['translit'] = builtin

  #   { "undefine",		FALSE,	FALSE,	TRUE,	m4_undefine },
  builtin = new PerlHash
  builtin['name'] = 'undefine'
  func = newsub _m4_undefine
  builtin['func'] = func 
  builtin_tab['undefine'] = builtin

  #   { "undivert",		FALSE,	FALSE,	FALSE,	m4_undivert },
  builtin = new PerlHash
  builtin['name'] = 'undivert'
  func = newsub _m4_not_implemented
  builtin['func'] = func 
  builtin_tab['undivert'] = builtin

.end


=head2 void _builtin_init( PerlHash state )

Initialise all builtin and predefined macros.

=cut

.sub _builtin_init 
  .param PerlHash state

  .local pmc builtin_tab
  builtin_tab = state['builtin_tab']
  .local pmc    builtin
  .local string name
  .local int    prefix_all_builtins
  prefix_all_builtins = state['prefix_all_builtins']
  .local pmc    iterator
  iterator = new Iterator, builtin_tab
  set iterator, .ITERATE_FROM_START
  ITER_LOOP:
  unless iterator, END_ITER
    builtin = shift iterator
    name = builtin['name']
    unless prefix_all_builtins goto DONT_PREFIX_ALL_BUILTINS
      name = 'm4_' . name
    DONT_PREFIX_ALL_BUILTINS:
    _define_builtin( state, name, builtin )
    goto ITER_LOOP
  END_ITER:
.end


=head2 void _define_builtin( PerlHash state, string name, string bp )

Install a builtin macro with name 'name', bound to the function 'bp'.

=cut

.sub _define_builtin 
  .param PerlHash  state
  .param string    name
  .param PerlHash  builtin

  .local pmc symtab
  symtab = state['symtab']

  # Now store the passed symbol
  .local pmc symbol
  symbol = new PerlHash
  symbol['name'] = name
  symbol['type'] = 'TOKEN_FUNC'

  .local string text
  text = builtin['name']
  symbol['text'] = text

  .local Sub func
  func = builtin['func']
  symbol['func'] = func

  symtab[name] = symbol
.end


=head2 void define_user_macro( PerlHash state, string name, string text )

Define a predefined or user-defined macro, with name 'name', and expansion 'text'. 
This function is also called from main(). 

=cut

.sub _define_user_macro 
  .param PerlHash  state
  .param string    name     
  .param string    text

  .local pmc symtab
  symtab = state['symtab']

  # Now store the passed symbol
  .local pmc symbol
  symbol = new PerlHash
  symbol['name'] = name
  symbol['text'] = text
  symbol['type'] = 'TOKEN_TEXT'

  symtab[name] = symbol
.end


=head2 _define_macro

The function define_macro is common for the builtins "define",
"undefine", "pushdef" and "popdef".  ARGC and ARGV is as for the caller,
and MODE argument determines how the macro name is entered into the
symbol table.							

=cut

.sub _define_macro 
  .param PerlHash  state
  .param string    name
  .param string    text

  # right now we handle only TOKEN_TEXT
  _define_user_macro( state, name, text )
.end


=head2 _m4_decr

Decrease a number.

=cut

.sub _m4_decr 
  .param PerlHash  state
  .param PerlArray arguments

  .local int arg0
  arg0 = arguments[0]
  dec arg0

  .local string ret
  ret = arg0

  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_define

Define a user defined macro.

=cut

.sub _m4_define 
  .param PerlHash  state
  .param PerlArray arguments

  # right now we handle only TOKEN_TEXT

  .local string arg0
  arg0 = arguments[0]
  .local string arg1
  arg1 = arguments[1]

  _define_macro( state, arg0, arg1 )

  .pcc_begin_return
    .return ''
  .pcc_end_return
.end


=head2 _m4_eval

Frontend for printf like formatting. 

=cut

.sub _m4_eval 
    .param PerlHash  state
    .param PerlArray arguments

    # get compiler
    compreg P1, "m4_eval_compiler"

    # compile code and run it
    .local string code
    code = arguments[0]
    .local pmc compiled_code
    compiled_code = compile P1, code
    P16 = new PerlString
    invoke compiled_code
    .local string ret
    ret = P16
    .pcc_begin_return
      .return ret
    .pcc_end_return
.end


=head2 _m4_format

Frontend for printf like formatting. 

=cut

.sub _m4_format 
  .param PerlHash  state
  .param PerlArray arguments

  .local string arg0
  arg0 = shift arguments

  .local string ret

  ret = sprintf arg0, arguments

  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_ifdef

A conditional. Check wether a macro is defined.

=cut

.sub _m4_ifdef 
  .param PerlHash  state
  .param PerlArray arguments

  .local string arg0
  arg0 = arguments[0]

  .local pmc symtab
  symtab = state['symtab']

  .local string ret
  .local int symbol_exists
  symbol_exists = exists symtab[arg0] 
  
  unless symbol_exists goto SYMBOL_DOES_NOT_EXIST
    ret = arguments[1]
    goto FINISH_M4_IFDEF
  SYMBOL_DOES_NOT_EXIST:
  ret = arguments[2]

  FINISH_M4_IFDEF:
  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_ifelse

A conditional. Can also be used a block comment or as a 
switch statement.

=cut

.sub _m4_ifelse 
  .param PerlHash  state
  .param PerlArray arguments

  .local string ret
  ret = ''

  .local int argc
  if argc == 2 goto USED_AS_BLOCK_QUOTE

  .local string arg0
  arg0 = arguments[0]
  .local string arg1
  arg1 = arguments[1]
  .local string arg2
  arg2 = arguments[2]
  .local string arg3
  arg3 = arguments[3]

  ne arg0, arg1, IS_NOT_EQUAL
    ret = arg2
    goto FINISH_M4_IFELSE
  IS_NOT_EQUAL:
  ret = arg3
  goto FINISH_M4_IFELSE

  USED_AS_BLOCK_QUOTE:
  FINISH_M4_IFELSE:
  .pcc_begin_return
    .return ret
  .pcc_end_return
.end



=head2 _m4_incr

Increase a number.

=cut

.sub _m4_incr 
  .param PerlHash  state
  .param PerlArray arguments

  .local int arg0
  arg0 = arguments[0]
  inc arg0

  .local string ret
  ret = arg0

  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_index

The macro expands to the first index of the second argument 
in the first argument. 

=cut

.sub _m4_index 
  .param PerlHash  state
  .param PerlArray arguments

  .local int index_int
  .local string arg0
  arg0 = arguments[0]
  .local string arg1
  arg1 = arguments[1]
  index_int = index arg0, arg1

  # Write integer into a string
  .local string ret
  ret = index_int

  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_len

Expand to the length of the first argument. 

=cut

.sub _m4_len 
  .param PerlHash  state
  .param PerlArray arguments

  .local string arg0
  arg0 = arguments[0]
  .local int len
  len = length arg0

  .local string ret
  ret = len

  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_substr

The macro "substr" extracts substrings from the first argument, starting
from the index given by the second argument, extending for a length
given by the third argument.  If the third argument is missing, the
substring extends to the end of the first argument.

=cut

.sub _m4_substr 

  .param PerlHash  state
  .param PerlArray arguments

  .local string ret

  .local int argc
  argc = arguments
  if argc < 2 goto FINISH_SUBSTR
  if argc > 3 goto FINISH_SUBSTR

  .local string in
  in = arguments[0]
  .local int start
  start = arguments[1]

  if argc != 2 goto LENGTH_PASSED
  ret = substr in, start 
  goto FINISH_SUBSTR

  LENGTH_PASSED:
  .local int len
  len = arguments[2]
  ret = substr in, start, len 
  goto FINISH_SUBSTR

  FINISH_SUBSTR:
  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_syscmd

Execute a shell command and don't return the return code.

=cut

.sub _m4_syscmd 
  .param PerlHash  state
  .param PerlArray arguments

  .local string arg0
  arg0 = arguments[0]

  .local string shell_cmd
  concat shell_cmd, '', arg0

  .local int exit_status
  exit_status = spawnw shell_cmd

  # Store it as a global for m4_sysval
  .local pmc exit_status_as_pmc
  exit_status_as_pmc = new PerlInt
  exit_status_as_pmc  = exit_status
  store_global 'exit_status', exit_status_as_pmc

  .pcc_begin_return
    .return ''
  .pcc_end_return
.end


=head2 _m4_sysval

Return the exit status of the last syscmd.

=cut

.sub _m4_sysval 
  .param PerlHash  state
  .param PerlArray arguments

  # Retrieve it as a global set by m4_sysval
  .local pmc exit_status_as_pmc
  find_global exit_status_as_pmc, 'exit_status'

  .local string ret
  ret = exit_status_as_pmc

  .pcc_begin_return
    .return ret
  .pcc_end_return
.end


=head2 _m4_undefine

Define a user defined macro.

=cut

.sub _m4_undefine 
  .param PerlHash  state
  .param PerlArray arguments

  .local string arg0
  arg0 = arguments[0]

  .local pmc symtab
  symtab = state['symtab']

  delete symtab[arg0]
  #print "undefining: "
  #print arg0
  #print "\n"
  #_dumper( 'symtab in undefine', symtab )
 
  .pcc_begin_return
    .return ''
  .pcc_end_return
.end


=head2 _m4_not_implemented

A placeholder for unimplemented functions.

=cut

.sub _m4_not_implemented 
  .param PerlHash  state
  .param PerlArray arguments

  .pcc_begin_return
    .return 'not implemented yet'
  .pcc_end_return
.end
