=head1 NAME 

input.imc - Setting up input and reading input

=head1 DESCRIPTION

Copyright:  2004 Bernhard Schmalhofer. All Rights Reserved.
CVS Info:   $Id$
History:    Ported from GNU m4 1.4
References: http://www.gnu.org/software/m4/m4.html

=head1 SUBROUTINES

=head2 void _input_init( PerlHash state )

Initialize the state hash.
'file_stack' contains input files.
'word_regex' recognizes words.
'string_regex' recognizes quoted strings.
'define_regex' recognizes the define macro
'line_regex' temporarily for line based workaraunds
'simple_regex' recognizes TOKEN_SIMPLE
'comment_regex' recognizes comments, returned as TOKEN_SIMPLE

TODO: recognize nested quoted strings

=cut
.sub _input_init prototyped             
  .param PerlHash state 

  .sym int does_exist

  # setup of 'file_stack'
  exists does_exist, state['file_stack']
  if does_exist goto FILE_STACK_EXISTS
    .sym pmc empty_array
    empty_array = new PerlArray
    state['file_stack'] = empty_array
  FILE_STACK_EXISTS:

  # regular expressions are needed for finding words and quoted strings
  .sym string err
  repeat err, ' ', 500
  .sym int erroffset
  .sym pmc NULL
  null NULL

  .sym pmc pcre_lib
  loadlib pcre_lib, "libpcre"

  # pcre *pcre_compile(const char *pattern, int options,
  #            const char **errptr, int *erroffset,
  #            const unsigned char *tableptr
  .sym pmc pcre_compile
  dlfunc pcre_compile, pcre_lib, "pcre_compile", "ptiB3P"

  #int pcre_exec(const pcre *code, const pcre_extra *extra,
  #        const char *subject, int length, int startoffset,
  #        int options, int *ovector, int ovecsize);
  .sym pmc pcre_exec
  dlfunc pcre_exec, pcre_lib, "pcre_exec", "ipPtiiipi"
  state['pcre_exec'] = pcre_exec

  #int pcre_copy_substring(const char *subject, int *ovector,
  #        int stringcount, int stringnumber, char *buffer,
  #        int buffersize);
  .sym pmc pcre_copy_substring
  dlfunc pcre_copy_substring, pcre_lib, "pcre_copy_substring", "itpiibi"
  state['pcre_copy_substring'] = pcre_copy_substring

  # setup of 'simple_regex'
  exists does_exist, state['simple_regex']
  if does_exist goto SIMPLE_REGEX_EXISTS
    .sym pmc simple_regex
    .pcc_begin prototyped
      .arg "^[^`#_a-zA-Z]+"             # pattern
      .arg 0                           # options
      .arg err                         # string of length 500
      .arg erroffset                   # index in pattern, which error occurs
      .arg NULL
    .nci_call pcre_compile
      .result simple_regex
    .pcc_end
    state['simple_regex'] = simple_regex
  SIMPLE_REGEX_EXISTS:

  # setup of 'comment_regex'
  exists does_exist, state['comment_regex']
  if does_exist goto COMMENT_REGEX_EXISTS
    .sym pmc comment_regex
    .pcc_begin prototyped
      .arg "^#[^\n]*\n"             # pattern
      .arg 0                           # options
      .arg err                         # string of length 500
      .arg erroffset                   # index in pattern, which error occurs
      .arg NULL
    .nci_call pcre_compile
      .result comment_regex
    .pcc_end
    state['comment_regex'] = comment_regex
  COMMENT_REGEX_EXISTS:

  # setup of 'word_regex'
  exists does_exist, state['word_regex']
  if does_exist goto WORD_REGEX_EXISTS
    .sym pmc word_regex
    .pcc_begin prototyped
      .arg '^[_a-zA-Z][_a-zA-Z0-9]*'   # pattern
      .arg 0                           # options
      .arg err                         # string of length 500
      .arg erroffset                   # index in pattern, which error occurs
      .arg NULL
    .nci_call pcre_compile
      .result word_regex
    .pcc_end
    state['word_regex'] = word_regex
  WORD_REGEX_EXISTS:

  # setup of 'string_regex'
  exists does_exist, state['string_regex']
  if does_exist goto QUOTED_STRING_REGEX_EXISTS
    .sym pmc string_regex
    .pcc_begin prototyped
      .arg "^`[^`]*'"                  # pattern
      .arg 0                           # options
      .arg err                         # string of length 500
      .arg erroffset                   # index in pattern, which error occurs
      .arg NULL
    .nci_call pcre_compile
      .result string_regex
    .pcc_end
    state['string_regex'] = string_regex
  QUOTED_STRING_REGEX_EXISTS:

  # setup of 'define_regex'
  exists does_exist, state['define_regex']
  if does_exist goto DEFINE_REGEX_EXISTS
    .sym pmc define_regex
    .pcc_begin prototyped
      .arg "^define\\(\\s*`[^']*',\\s*`[^']*'\\)" # pattern
      .arg 0                           # options
      .arg err                         # string of length 500
      .arg erroffset                   # index in pattern, which error occurs
      .arg NULL
    .nci_call pcre_compile
      .result define_regex
    .pcc_end
    state['define_regex'] = define_regex
  DEFINE_REGEX_EXISTS:

  exists does_exist, state['line_regex']
  if does_exist goto LINE_REGEX_EXISTS
    .sym pmc line_regex
    .pcc_begin prototyped
      .arg '^[^\n]*\n'                  # pattern
      .arg 0                           # options
      .arg err                         # string of length 500
      .arg erroffset                   # index in pattern, which error occurs
      .arg NULL
    .nci_call pcre_compile
      .result line_regex
    .pcc_end
    state['line_regex'] = line_regex
  LINE_REGEX_EXISTS:

  .pcc_begin_return
    # Nothing to be returned
  .pcc_end_return
.end


=head2 void push_file( PerlHash state, string filename )

Stores a filename on a stack
TODO: open these files and complain when they don't or pass filehandles

=cut
.sub _push_file prototyped             
  .param PerlHash state 
  .param string   filename    

  # state['file_stack'] has been created in input_init 
  .sym pmc file_stack
  file_stack = state['file_stack']
  push file_stack, filename

  .pcc_begin_return
    # Nothing to be returned
  .pcc_end_return
.end


=head2 string, string next_token( PerlHash state )

Uses regular expressions for finding tokens.

=cut
.sub _next_token prototyped            
  .param PerlHash state 

  .sym string current_file    
  current_file = state['current_file']
  .sym int current_file_len
  length current_file_len, current_file    
  .sym pmc pcre_exec    
  pcre_exec = state['pcre_exec']
  .sym pmc NULL
  null NULL
  .sym pmc ovector
  ovector = new ManagedStruct
  ovector = 120       # 1/(2/3) * 4  * 2 * 10 for 10 result pairs
  .sym int ok
  .sym pmc regex    
  .sym string token_type
  token_type = 'TOKEN_EOF'
  .sym string token_data
  token_data = ''
    
  # look for 'TOKEN_SIMPLE'
  # read a whole bunch of non-macro and non-word charcters
  regex = state['simple_regex']
  token_type = 'TOKEN_SIMPLE'
  .pcc_begin prototyped
    .arg regex
    .arg NULL           # P extra
    .arg current_file   # t subject
    .arg current_file_len    
    .arg 0
    .arg 0
    .arg ovector        # p ovector
    .arg 10             # i ovecsize
  .nci_call pcre_exec
    .result ok
  .pcc_end
  if ok ==  1 goto MATCH
  if ok != -1 goto MATCH_FAILED

  # look for comments and return it as 'TOKEN_SIMPLE'
  regex = state['comment_regex']
  token_type = 'TOKEN_SIMPLE'
  .pcc_begin prototyped
    .arg regex
    .arg NULL           # P extra
    .arg current_file   # t subject
    .arg current_file_len    
    .arg 0
    .arg 0
    .arg ovector        # p ovector
    .arg 10             # i ovecsize
  .nci_call pcre_exec
    .result ok
  .pcc_end
  if ok ==  1 goto MATCH
  if ok != -1 goto MATCH_FAILED

  # look for 'TOKEN_STRING'
  regex = state['string_regex']
  token_type = 'TOKEN_STRING'
  .pcc_begin prototyped
    .arg regex
    .arg NULL           # P extra
    .arg current_file   # t subject
    .arg current_file_len    
    .arg 0
    .arg 0
    .arg ovector        # p ovector
    .arg 10             # i ovecsize
  .nci_call pcre_exec
    .result ok
  .pcc_end
  if ok ==  1 goto MATCH
  if ok != -1 goto MATCH_FAILED

  # look for 'TOKEN_DEFINE'
  # temporary workaround, should be 'TOKEN_WORD'
  regex = state['define_regex']
  token_type = 'TOKEN_DEFINE'
  .pcc_begin prototyped
    .arg regex
    .arg NULL           # P extra
    .arg current_file   # t subject
    .arg current_file_len    
    .arg 0
    .arg 0
    .arg ovector        # p ovector
    .arg 10             # i ovecsize
  .nci_call pcre_exec
    .result ok
  .pcc_end
  if ok ==  1 goto MATCH
  if ok != -1 goto MATCH_FAILED

  # look for 'TOKEN_WORD'
  # this will be checked for macro substitution
  regex = state['word_regex']
  token_type = 'TOKEN_WORD'
  .pcc_begin prototyped
    .arg regex
    .arg NULL           # P extra
    .arg current_file   # t subject
    .arg current_file_len    
    .arg 0
    .arg 0
    .arg ovector        # p ovector
    .arg 10             # i ovecsize
  .nci_call pcre_exec
    .result ok
  .pcc_end
  if ok ==  1 goto MATCH
  if ok != -1 goto MATCH_FAILED

  if current_file_len != 0 goto MATCH_FAILED 
  token_type = 'TOKEN_EOF'
  token_data = ''
  goto FINISH_NEXT_TOKEN 

  MATCH:
    # ovector is an int arrary containing start stop coords
    .sym int start_line
    .sym int end_line
    .sym pmc struct
    struct = new SArray
    struct = 3
    .include "datatypes.pasm"
    struct[0] = .DATATYPE_INT
    struct[1] = 2
    struct[2] = 0
    assign ovector, struct
    start_line = ovector[0;0]
    end_line   = ovector[0;1]
    substr token_data, current_file, start_line, end_line, ''
  goto FINISH_NEXT_TOKEN

  MATCH_FAILED:
    printerr "failed to match !"
    printerr current_file
    printerr "!\n"     
  goto FINISH_NEXT_TOKEN

  FINISH_NEXT_TOKEN: 
  .pcc_begin_return
    .return token_type
    .return token_data
  .pcc_end_return
.end
