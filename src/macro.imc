=head1 NAME

src/macro.imc - does macro substitution

=head1 DESCRIPTION

Copyright:  2004 Bernhard Schmalhofer.  All Rights Reserved.
CVS Info:   $Id$
History:    Ported from GNU m4 1.4
References: http://www.gnu.org/software/m4/m4.html

=head1 SUBROUTINES

=head2 void _expand_input( PerlHash state )

Loop through some input files.
TODO: read files in next_token()

=cut

.sub _expand_input prototyped             
  .param PerlHash  state    

  .local Sub expand_token
  expand_token = newsub _expand_token
  .local Sub next_token
  next_token = newsub _next_token

  # loop over the lines of a list of of files
  # TODO: implement a lexer which does m4 stuff correctly
  .local PerlArray file_stack
  file_stack = state['file_stack']
  .local string filename
  NEXT_FILE:
  .local int num_files
  num_files = file_stack
  if num_files <= 0 goto ALL_FILES_EXPANDED
    shift filename, file_stack
    .local pmc in                 # input file handle
    open in, filename, "<"
    if in, PROCESS_SINGLE_FILE
      printerr filename
      printerr " not found\n"
      .pcc_begin_return
        .return 0       
      .pcc_end_return
    PROCESS_SINGLE_FILE:
    .local string current_file    # input file handle
    read current_file, in, 50000
    state['current_file'] = current_file
    close in
    # now go through the file, token for token 
    .local string token_data         
    .local string token_type         
  goto NEXT_TOKEN

  EXPAND_TOKEN:

  .pcc_begin prototyped
    .arg state
    .arg token_type
    .arg token_data
  .pcc_call expand_token
    ret_expand_token_1:
  .pcc_end

  NEXT_TOKEN:
  .pcc_begin prototyped
    .arg state
  .pcc_call next_token
    ret_next_token_1:
    .result token_type
    .result token_data
  .pcc_end
  ne token_type, 'TOKEN_EOF', EXPAND_TOKEN
  goto NEXT_FILE

  ALL_FILES_EXPANDED:
  .pcc_begin_return
    # void
  .pcc_end_return
.end


=head2 void _expand_token( PerlHash state, string token_type, string token_data )

Expand one token, according to its type.  Potential macro names
(TOKEN_WORD) are looked up in the symbol table, to see if they have a
macro definition.  If they have, they are expanded as macros, otherwise
the text are just copied to the output.

=cut

.sub _expand_token prototyped            
  .param PerlHash  state    
  .param string    token_type
  .param string    token_data

=for skip

  print "------- expand_token -------------\n"
  print "token_type: "
  print token_type
  print "\ntoken_data: "
  print token_data
  print "\n----------------------------------\n"

=cut

  .local OrderedHash symtab
  symtab = state['symtab']
  .local string current_file    
  current_file = state['current_file']

  eq token_type, 'TOKEN_EOF',    FINISH_EXPAND_TOKEN
  eq token_type, 'TOKEN_MACDEF', FINISH_EXPAND_TOKEN

  # 'TOKEN_STRING' is the same as 'TOKEN_SIMPLE', 
  # besides cutting left and right delimiters
  ne token_type, 'TOKEN_STRING', NO_TOKEN_STRING 
    # Get rid of starting `
    substr token_data, 0, 1, ''
    # Get rid of trailing '
    chopn token_data, 1
    goto SHIPOUT_TEXT
  NO_TOKEN_STRING:

  eq token_type, 'TOKEN_SIMPLE', SHIPOUT_TEXT

  ne token_type, 'TOKEN_WORD', NO_TOKEN_WORD
    .local int symbol_exists
    exists symbol_exists, symtab[token_data] 
    unless symbol_exists goto SHIPOUT_TEXT
      .local pmc symbol
      symbol = symtab[token_data] 
      .local string symbol_type
      symbol_type = symbol['type']
      eq token_type, 'TOKEN_VOID', SHIPOUT_TEXT
        ne symbol_type, 'TOKEN_FUNC', EXPAND_MACRO
          .local string first_char
          substr first_char, current_file, 0, 1
          ne first_char, '(', SHIPOUT_TEXT
          goto EXPAND_MACRO

  EXPAND_MACRO:
  .local Sub expand_macro
  expand_macro = newsub _expand_macro
  .pcc_begin prototyped
    .arg state
    .arg symbol
    .arg token_data
  .pcc_call expand_macro
    ret_expand_macro_6:
    .result token_data
  .pcc_end
  goto SHIPOUT_TEXT

  NO_TOKEN_WORD:
  printerr "unknown token type: "
  printerr token_type
  end

  SHIPOUT_TEXT:
  .local Sub shipout_text
  shipout_text = newsub _shipout_text
  .pcc_begin prototyped
    .arg state
    .arg token_data
  .pcc_call shipout_text
    ret_shipout_text_6:
  .pcc_end
  
  FINISH_EXPAND_TOKEN:
  .pcc_begin_return
    # void
  .pcc_end_return
.end


=head2 string processed_token _expand_macro( PerlArray macro, string token )

Apply macro to a token.

TODO: look for TOKEN_FUNC

=cut

.sub _expand_macro prototyped            
  .param PerlHash  state
  .param PerlHash  symbol 
  .param string    token_data         

  .local string current_file    
  current_file = state['current_file']
  .local string symbol_type
  symbol_type = symbol['type']

=for skip

  print "------- expand_macro -------------\n"
  print "token_data: "
  print token_data
  print "\nsymbol_type: "
  print symbol_type
  print "\ncurrent_file: "
  print current_file
  print "\n----------------------------------\n"

=cut

  .local string arg_1
  arg_1 = ''
  .local string arg_2
  arg_2 = ''

  ne symbol_type, 'TOKEN_FUNC', NO_TOKEN_FUNC 
    # print "got a TOKEN_FUNC or a TOKEN_TEXT\n"
    # a line has already successfully been read in
    # We want match something like:
    # "define('furcht', 'Hallo Welt')"
    # and capture the name 'furcht' and the substitution 'Hallo Welt'.
    # Thus we need to remenber the start and the length of these two captures
    .local int len_arg_1
    .local int start_arg_1
    .local int len_arg_1
    .local int starg_arg_2
    .local int len_arg_2
    .local int start_index
    start_index = 0
    .local int current_index
    rx_search current_file, current_index, start_index, "(", NO_TOKEN_FUNC  
    # TODO skip only blanks
    start_index = current_index
    rx_search current_file, current_index, start_index, "`", NO_TOKEN_FUNC  
    start_index = current_index
    start_arg_1 = current_index
    rx_search current_file, current_index, start_index, "'", NO_TOKEN_FUNC  
    start_index = current_index
    len_arg_1 = current_index - start_arg_1
    dec len_arg_1
    rx_search current_file, current_index, start_index, ",", NO_TOKEN_FUNC  
    start_index = current_index
    rx_search current_file, current_index, start_index, "`", NO_TOKEN_FUNC  
    start_index = current_index
    starg_arg_2 = current_index
    rx_search current_file, current_index, start_index, "'", NO_TOKEN_FUNC  
    start_index = current_index
    len_arg_2 = start_index - starg_arg_2
    dec len_arg_2
    rx_search current_file, current_index, start_index, ")", NO_TOKEN_FUNC  
    start_index = current_index
    # All needed matches were successfull,
    # so we can assemble the input for 'call_macro'
    substr arg_1, current_file, start_arg_1, len_arg_1
    substr arg_2, current_file, starg_arg_2, len_arg_2
    # The parsed stuff can be deleted from 'current_file'
    substr current_file, 0, current_index, ''

  NO_TOKEN_FUNC:

  .local string text
  .local Sub call_macro
  call_macro = newsub _call_macro
  .pcc_begin prototyped
    .arg state
    .arg symbol 
    .arg arg_1
    .arg arg_2
  .pcc_call call_macro
    ret_call_macro_1:
    .result text
  .pcc_end

  .pcc_begin_return
    .return text
  .pcc_end_return
.end


=head2 string processed_token _call_macro( PerlArray macro, string token )

Apply macro to a token.

TODO: distinguish between TOKEN_FUNC and TOKEN_WORD

=cut

.sub _call_macro prototyped            
  .param PerlHash state
  .param pmc      symbol
  .param string   arg_1
  .param string   arg_2

  .local string symbol_type
  symbol_type = symbol['type']
  .local string symbol_name
  symbol_name = symbol['name']

=for skip

  print "------- call_macro -------------\n"
  print "symbol_name: "
  print symbol_name
  print "\nsymbol_type: "
  print symbol_type
  print "\narg_1: "
  print arg_1
  print "\narg_2: "
  print arg_2
  print "\n----------------------------------\n"

=cut

  .local string    text

  ne symbol_type, 'TOKEN_TEXT', NO_TOKEN_TEXT
    text = symbol['text']
    goto FINISH_CALL_MACRO
  NO_TOKEN_TEXT:

  eq symbol_type, 'TOKEN_FUNC', TOKEN_FUNC
    printerr "INTERNAL ERROR: Bad symbol type in call_macro"
    end
  TOKEN_FUNC:
  .local pmc func
  func = symbol['func']
  .pcc_begin prototyped
    .arg state
    .arg arg_1
    .arg arg_2
  .pcc_call func
    ret_func_1:
    .result text
  .pcc_end

  FINISH_CALL_MACRO:
  .pcc_begin_return
    .return text
  .pcc_end_return
.end
