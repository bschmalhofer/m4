=head1 NAME

src/macro.imc - does macro substitution

=head1 DESCRIPTION

Copyright:  2004 Bernhard Schmalhofer.  All Rights Reserved.
CVS Info:   $Id$
History:    Ported from GNU m4 1.4
References: http://www.gnu.org/software/m4/m4.html

=head1 SUBROUTINES

=head2 void _expand_input( PerlHash state )

Loop through some input files.
TODO: read files in next_token()

=cut

.sub _expand_input 
  .param PerlHash  state    

  .local string token_data  # current token         
  .local string token_type  # type of current token      

  # go through the input, token for token 
  NEXT_TOKEN:   
  ( token_type, token_data ) = _next_token( state )
  _expand_token( state, token_type, token_data )
  ne token_type, 'TOKEN_EOF', NEXT_TOKEN

  FINISH_EXPAND_INPUT:
.end


=head2 void _expand_token( PerlHash state, string token_type, string token_data )

Expand one token, according to its type.  Potential macro names
(TOKEN_WORD) are looked up in the symbol table, to see if they have a
macro definition.  If they have, they are expanded as macros, otherwise
the text are just copied to the output.

=cut

.sub _expand_token 
  .param PerlHash  state    
  .param string    token_type
  .param string    token_data

  .local pmc symtab
  symtab = state['symtab']

  eq token_type, 'TOKEN_EOF',    FINISH_EXPAND_TOKEN
  eq token_type, 'TOKEN_MACDEF', FINISH_EXPAND_TOKEN

  # 'TOKEN_STRING' is the same as 'TOKEN_SIMPLE', 
  eq token_type, 'TOKEN_STRING', SHIPOUT_TEXT
  eq token_type, 'TOKEN_SIMPLE', SHIPOUT_TEXT

  ne token_type, 'TOKEN_WORD', NO_TOKEN_WORD
    .local int symbol_exists
    exists symbol_exists, symtab[token_data] 
    unless symbol_exists goto SHIPOUT_TEXT
      .local pmc symbol
      symbol = symtab[token_data] 
      .local string symbol_type
      symbol_type = symbol['type']
      eq token_type, 'TOKEN_VOID', SHIPOUT_TEXT
        ne symbol_type, 'TOKEN_FUNC', EXPAND_MACRO
          .local string current_file    
          current_file = state['input_stack';0;'string']
          .local int first_char
          first_char = ord current_file
          .local int open_parenthesis
          open_parenthesis = ord '('
          ne first_char, open_parenthesis, SHIPOUT_TEXT
          goto EXPAND_MACRO

  EXPAND_MACRO:
  _expand_macro( state, symbol )
  goto FINISH_EXPAND_TOKEN

  NO_TOKEN_WORD:
  printerr "unknown token type: "
  printerr token_type
  end

  SHIPOUT_TEXT:
  _shipout_text( state, token_data )
  goto FINISH_EXPAND_TOKEN
  
  FINISH_EXPAND_TOKEN:
.end


=head2 string processed_token _expand_macro( PerlHash state, PerlHash symbol )

The macro expansion is handled by expand_macro(). It parses the
arguments, using collect_arguments(), and builds a PerlArray containing 
the arguments. The arguments themselves are stored on a local obstack.
Expand_macro() uses call_macro() to do the call of the macro.	

Expand_macro() is potentially recursive, since it calls expand_argument(), 
which might call expand_token (), which might call expand_macro().

=cut

.sub _expand_macro 
  .param PerlHash  state
  .param PerlHash  symbol 

  .local int expansion_level
  expansion_level = state['expansion_level']
  .local int nesting_limit
  nesting_limit = state['nesting_limit']
  inc expansion_level
  if expansion_level <= nesting_limit goto NESTING_LIMIT_NOT_REACHED_YET
    printerr "ERROR: Recursion limit of "
    printerr nesting_limit
    printerr "exceeded, use -L<N> to change it" 
    end
  NESTING_LIMIT_NOT_REACHED_YET:
  state['expansion_level'] = expansion_level

  .local pmc arguments
  arguments = new PerlArray
  _collect_arguments( state, arguments )

  .local string text
  ( text ) = _call_macro( state, symbol, arguments )
  .local string current_file    
  current_file = state['input_stack';0;'string']
  current_file = text . current_file 
  state['input_stack';0;'string'] = current_file

  expansion_level = state['expansion_level']
  dec expansion_level
  state['expansion_level'] = expansion_level

.end


=head2 string processed_token _call_macro( PerlArray macro, string token )

Apply macro to a token.

TODO: distinguish between TOKEN_FUNC and TOKEN_WORD

=cut

.sub _call_macro 
  .param PerlHash  state
  .param pmc       symbol
  .param PerlArray arguments

  .local string symbol_type
  symbol_type = symbol['type']
  .local string symbol_name
  symbol_name = symbol['name']

  .local string    text
  ne symbol_type, 'TOKEN_TEXT', NO_TOKEN_TEXT
    text = symbol['text']
    goto FINISH_CALL_MACRO
  NO_TOKEN_TEXT:

  eq symbol_type, 'TOKEN_FUNC', TOKEN_FUNC
    printerr "INTERNAL ERROR: Bad symbol type in call_macro"
    end
  TOKEN_FUNC:
  .local pmc func
  func = symbol['func']
  .pcc_begin prototyped 
    .arg state
    .arg arguments
  .pcc_call func
    ret_func_1:
    .result text
  .pcc_end

  FINISH_CALL_MACRO:
  .pcc_begin_return
    .return text
  .pcc_end_return
.end


=head2 void _collect_arguments

Collect all the arguments to a call of a macro.

=cut

.sub _collect_arguments 
  .param PerlHash  state    
  .param PerlArray arguments

  # The macro name has already been read in, thus we need to match 
  # something like "('furcht', 'Hallo Welt')"
  # and capture the name 'furcht' and the substitution 'Hallo Welt'.
  # Thus we need to remenber the start and the length of these two captures
  .local int cnt_stack
  .local string current_file    
  current_file = state['input_stack';0;'string']

  # We need a '(' at beginning of string
  .local int index_opening
  index_opening = index current_file, '('  
  ne index_opening, 0, NOT_A_ARGUMENT_LIST

  # expand strings
  .local int start_index
  start_index = 0
  .local int num_args
  num_args = 0
  .local int index_comma
  .local int index_closing
  .local int index_start_string
  .local int index_end_string
  .local int len_string
  .local string arg
  EXPAND_ARG:
  # find a string before ')'
  index_closing = index current_file, ')', start_index
  if index_closing == -1 goto NO_MORE_ARGS
  if num_args == 0 goto SKIP_SKIP_COMMA
  index_comma = index current_file, ',', start_index
  if index_comma == -1 goto NO_MORE_ARGS
  if index_closing < index_comma goto NO_MORE_ARGS
  start_index = index_comma
  SKIP_SKIP_COMMA:
  index_start_string = index current_file, '`', start_index 
  if index_start_string == -1 goto NO_MORE_ARGS
  inc index_start_string
  if index_closing < index_start_string goto NO_MORE_ARGS
  index_end_string = index current_file, "'", index_start_string 
  if index_end_string == -1 goto NO_MORE_ARGS
  len_string = index_end_string - index_start_string
  substr arg, current_file, index_start_string, len_string
  start_index = index_end_string
  push arguments, arg
  num_args = arguments
  goto EXPAND_ARG

  NO_MORE_ARGS:
  inc index_closing
  substr current_file, 0, index_closing, ''
  
  NOT_A_ARGUMENT_LIST:
  state['input_stack';0;'string'] = current_file
.end
